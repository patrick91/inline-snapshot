{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#welcome-to-inline-snapshot","title":"Welcome to inline-snapshot","text":"<p>inline-snapshot can be used for different things:</p> <ul> <li>golden master/approval/snapshot testing.   The idea is that you have a function with a currently unknown result and you want to write a tests, which ensures that the result does not change during refactoring.</li> <li>Compare things which are complex like lists with lot of numbers or complex data structures.</li> <li>Things which might change during the development like error messages.</li> </ul> <p><code>inline-snapshot</code> automates the process of recording, storing and updating the value you want to compare with. The value is converted with <code>repr()</code> and stored in the source file as argument of the <code>snapshot()</code> function.</p>"},{"location":"#usage","title":"Usage","text":"<p>You can use <code>snapshot()</code> instead of the value which you want to compare with and run the tests to record the correct values.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 1548 * 18489\n\n\ndef test_something():\n    assert something() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\n\n\ndef something():\n    return 1548 * 18489\n\n\ndef test_something():\n    assert something() == snapshot(28620972)\n</code></pre></p> <p>Your tests will break, if you change your code by adding <code>// 18</code>. Maybe that is correct and you should fix your code, or your code is correct and you want to update your test results.</p> changed code--inline-snapshot=fix <p> <pre><code>def something():\n    return (1548 * 18489) // 18\n\n\ndef test_something():\n    assert something() == snapshot(28620972)\n</code></pre></p> <p> <pre><code>def something():\n    return (1548 * 18489) // 18\n\n\ndef test_something():\n    assert something() == snapshot(1590054)\n</code></pre></p> <p>Please verify the new results. <code>git diff</code> will give you a good overview over all changed results. Use <code>pytest -k test_something --inline-snapshot=fix</code> if you only want to change one test.</p>"},{"location":"#supported-operations","title":"Supported operations","text":"<p>You can use <code>snapshot(x)</code> like you can use <code>x</code> in your assertion with a limited set of operations:</p> <ul> <li><code>value == snapshot()</code> to compare with something,</li> <li><code>value &lt;= snapshot()</code> to ensure that something gets smaller/larger over time (number of iterations of an algorithm you want to optimize for example),</li> <li><code>value in snapshot()</code> to check if your value is in a known set of values,</li> <li><code>snapshot()[key]</code> to generate new sub-snapshots on demand.</li> </ul> <p>Warning</p> <p>One snapshot can only be used with one operation. The following code will not work:  <pre><code>def test_something():\n    s = snapshot(5)\n    assert 5 &lt;= s\n    assert 5 == s\n\n\n# Error:\n# &gt;       assert 5 == s\n# E       TypeError: This snapshot cannot be use with `==`, because it was previously used with `x &lt;= snapshot`\n</code></pre></p>"},{"location":"#supported-usage","title":"Supported usage","text":"<p>It is possible to place <code>snapshot()</code> anywhere in the tests and reuse it multiple times.</p> original code--inline-snapshot=create <p> <pre><code>def something():\n    return 21 * 2\n\n\nresult = snapshot()\n\n\ndef test_something():\n    ...\n    assert something() == result\n\n\ndef test_something_again():\n    ...\n    assert something() == result\n</code></pre></p> <p> <pre><code>def something():\n    return 21 * 2\n\n\nresult = snapshot(42)\n\n\ndef test_something():\n    ...\n    assert something() == result\n\n\ndef test_something_again():\n    ...\n    assert something() == result\n</code></pre></p> <p><code>snapshot()</code> can also be used in loops:</p> original code--inline-snapshot=create <p> <pre><code>def test_loop():\n    for name in [\"Mia\", \"Eva\", \"Leo\"]:\n        assert len(name) == snapshot()\n</code></pre></p> <p> <pre><code>def test_loop():\n    for name in [\"Mia\", \"Eva\", \"Leo\"]:\n        assert len(name) == snapshot(3)\n</code></pre></p> <p>or passed as an argument to a function:</p> original code--inline-snapshot=create <p> <pre><code>def check_string_len(string, snapshot_value):\n    assert len(string) == snapshot_value\n\n\ndef test_string_len():\n    check_string_len(\"abc\", snapshot())\n    check_string_len(\"1234\", snapshot())\n    check_string_len(\".......\", snapshot())\n</code></pre></p> <p> <pre><code>def check_string_len(string, snapshot_value):\n    assert len(string) == snapshot_value\n\n\ndef test_string_len():\n    check_string_len(\"abc\", snapshot(3))\n    check_string_len(\"1234\", snapshot(4))\n    check_string_len(\".......\", snapshot(7))\n</code></pre></p>"},{"location":"#code-generation","title":"Code generation","text":"<p>You can use almost any python datatype and also complex values like <code>datatime.date</code>, because <code>repr()</code> is used to convert the values to a source code. It might be necessary to import the right modules to match the <code>repr()</code> output.</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef something():\n    return {\n        \"name\": \"hello\",\n        \"one number\": 5,\n        \"numbers\": list(range(10)),\n        \"sets\": {1, 2, 15},\n        \"datetime\": datetime.date(1, 2, 22),\n        \"complex stuff\": 5j + 3,\n        \"bytes\": b\"fglecg\\n\\x16\",\n    }\n\n\ndef test_something():\n    assert something() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef something():\n    return {\n        \"name\": \"hello\",\n        \"one number\": 5,\n        \"numbers\": list(range(10)),\n        \"sets\": {1, 2, 15},\n        \"datetime\": datetime.date(1, 2, 22),\n        \"complex stuff\": 5j + 3,\n        \"bytes\": b\"fglecg\\n\\x16\",\n    }\n\n\ndef test_something():\n    assert something() == snapshot(\n        {\n            \"name\": \"hello\",\n            \"one number\": 5,\n            \"numbers\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n            \"sets\": {1, 2, 15},\n            \"datetime\": datetime.date(1, 2, 22),\n            \"complex stuff\": (3 + 5j),\n            \"bytes\": b\"fglecg\\n\\x16\",\n        }\n    )\n</code></pre></p> <p>The code is generated in the following way:</p> <ol> <li>The value is copied with <code>value = copy.deepcopy(value)</code></li> <li>The code is generated with <code>repr(value)</code></li> <li> <p>Strings which contain newlines are converted to triple quoted strings.</p> <p>Note</p> <p>Missing newlines at start or end are escaped (since 0.4.0).</p> original code--inline-snapshot=update <p> <pre><code>def test_something():\n    assert \"first line\\nsecond line\" == snapshot(\n        \"\"\"first line\nsecond line\"\"\"\n    )\n</code></pre></p> <p> <pre><code>def test_something():\n    assert \"first line\\nsecond line\" == snapshot(\n        \"\"\"\\\nfirst line\nsecond line\\\n\"\"\"\n    )\n</code></pre></p> </li> <li> <p>The code is formatted with black.</p> <p>Note</p> <p>The black formatting of the whole file could not work for the following reasons:</p> <ol> <li>black is configured with cli arguments and not in a configuration file. Solution: configure black in a configuration file</li> <li>inline-snapshot uses a different black version. Solution: specify which black version inline-snapshot should use by adding black with a specific version to your dependencies.</li> </ol> </li> <li> <p>The whole file is formatted with black if it was formatted before.</p> </li> </ol>"},{"location":"#feedback","title":"Feedback","text":"<p>inline-snapshot provides some advanced ways to work with snapshots.</p> <p>I would like to know how these features are used to further improve this small library. Let me know if you've found interesting use cases for this library via twitter or in the github discussions.</p>"},{"location":"#issues","title":"Issues","text":"<p>If you encounter any problems, please report an issue along with a detailed description.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v080-2024-04-09","title":"v0.8.0 (2024-04-09)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>prevent dirty-equal values from triggering of updates</li> <li>fix lists by calculating the alignment of the changed values</li> <li>insert dict items</li> <li>delete dict items</li> <li>preserve not changed dict-values and list-elements</li> </ul>"},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>update with UndecidedValue</li> <li>handle dicts with mulitple insertions and deletions</li> <li>handle lists with mulitple insertions and deletions</li> <li>fixed typing and coverage</li> </ul>"},{"location":"changelog/#refactor","title":"Refactor","text":"<ul> <li>removed old needs* logic</li> <li>removed get_result</li> <li>use _get_changes api for DictValue</li> <li>use _get_changes api for CollectionValue</li> <li>use _get_changes api for MinMaxValue</li> <li>use _get_changes</li> <li>moved some functions</li> </ul>"},{"location":"changelog/#v070-2024-02-27","title":"v0.7.0 (2024-02-27)","text":""},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>removed old --update-snapshots option</li> </ul>"},{"location":"changelog/#v061-2024-01-28","title":"v0.6.1 (2024-01-28)","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>use utf-8 encoding to read and write source files</li> </ul>"},{"location":"changelog/#v060-2023-12-10","title":"v0.6.0 (2023-12-10)","text":""},{"location":"changelog/#feat_2","title":"Feat","text":"<ul> <li>store snapshot values in external files</li> </ul>"},{"location":"changelog/#v052-2023-11-13","title":"v0.5.2 (2023-11-13)","text":""},{"location":"changelog/#fix_2","title":"Fix","text":"<ul> <li>remove upper bound from dependencies in pyproject.toml</li> </ul>"},{"location":"changelog/#v051-2023-10-20","title":"v0.5.1 (2023-10-20)","text":""},{"location":"changelog/#fix_3","title":"Fix","text":"<ul> <li>show better error messages</li> </ul>"},{"location":"changelog/#v050-2023-10-15","title":"v0.5.0 (2023-10-15)","text":""},{"location":"changelog/#feat_3","title":"Feat","text":"<ul> <li>support 3.12</li> </ul>"},{"location":"changelog/#fix_4","title":"Fix","text":"<ul> <li>do not change empty snapshot if it is not used</li> </ul>"},{"location":"changelog/#v040-2023-09-29","title":"v0.4.0 (2023-09-29)","text":""},{"location":"changelog/#feat_4","title":"Feat","text":"<ul> <li>escaped linebreak at the start/end of multiline strings</li> </ul>"},{"location":"changelog/#fix_5","title":"Fix","text":"<ul> <li>added py.typed</li> </ul>"},{"location":"changelog/#v032-2023-07-31","title":"v0.3.2 (2023-07-31)","text":""},{"location":"changelog/#fix_6","title":"Fix","text":"<ul> <li>handle update flag in sub-snapshots correctly</li> <li>fixed some edge cases where sub-snapshots had problems with some flags</li> <li>string literal concatenation should trigger no update</li> </ul>"},{"location":"changelog/#v031-2023-07-14","title":"v0.3.1 (2023-07-14)","text":""},{"location":"changelog/#fix_7","title":"Fix","text":"<ul> <li>added <code>__all__</code> to inline_snapshot</li> <li>flags fix/trim/create/update are changing the matching snapshots</li> </ul>"},{"location":"changelog/#v030-2023-07-12","title":"v0.3.0 (2023-07-12)","text":""},{"location":"changelog/#breaking-change","title":"BREAKING CHANGE","text":"<ul> <li>values have to be copyable with <code>copy.deepcopy</code></li> </ul>"},{"location":"changelog/#fix_8","title":"Fix","text":"<ul> <li>snapshot the current value of mutable objects   <pre><code>l = [1]\nassert l == snapshot([1])  # old behaviour: snapshot([1, 2])\nl.append(2)\nassert l == snapshot([1, 2])\n</code></pre></li> </ul>"},{"location":"changelog/#v021-2023-07-09","title":"v0.2.1 (2023-07-09)","text":""},{"location":"changelog/#fix_9","title":"Fix","text":"<ul> <li>black configuration files are respected</li> </ul>"},{"location":"changelog/#v020-2023-06-20","title":"v0.2.0 (2023-06-20)","text":""},{"location":"changelog/#feat_5","title":"Feat","text":"<ul> <li><code>value &lt;= snapshot()</code> to ensure that something gets smaller/larger over time (number of iterations of an algorithm you want to optimize for example),</li> <li><code>value in snapshot()</code> to check if your value is in a known set of values,</li> <li> <p><code>snapshot()[key]</code> to generate new sub-snapshots on demand.</p> </li> <li> <p>convert strings with newlines to triple quoted strings   <pre><code>assert \"a\\nb\\n\" == snapshot(\n    \"\"\"a\nb\n\"\"\"\n)\n</code></pre></p> </li> <li>preserve black formatting</li> </ul>"},{"location":"changelog/#v012-2022-12-11","title":"v0.1.2 (2022-12-11)","text":""},{"location":"changelog/#fix_10","title":"Fix","text":"<ul> <li>updated executing</li> </ul>"},{"location":"changelog/#v011-2022-12-08","title":"v0.1.1 (2022-12-08)","text":""},{"location":"changelog/#fix_11","title":"Fix","text":"<ul> <li>fixed typo in pytest plugin name</li> </ul>"},{"location":"changelog/#v010-2022-07-25","title":"v0.1.0 (2022-07-25)","text":""},{"location":"changelog/#feat_6","title":"Feat","text":"<ul> <li>first inline-snapshot version</li> </ul>"},{"location":"cmp_snapshot/","title":"x <= snapshot()","text":""},{"location":"cmp_snapshot/#general","title":"General","text":"<p>A snapshot can be compared against any value with <code>&lt;=</code> or <code>&gt;=</code>. This can be used to create a upper/lower bound for some result. The snapshot value can be trimmed to the lowest/largest valid value.</p> <p>Example:</p> original code--inline-snapshot=createoptimized code --inline-snapshot=trim <p> <pre><code>def gcd(x, y):\n    iterations = 0\n    if x &gt; y:\n        small = y\n    else:\n        small = x\n    for i in range(1, small + 1):\n        iterations += 1\n        if (x % i == 0) and (y % i == 0):\n            gcd = i\n\n    return gcd, iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot()\n    assert iterations &lt;= snapshot()\n</code></pre></p> <p> <pre><code>def gcd(x, y):\n    iterations = 0\n    if x &gt; y:\n        small = y\n    else:\n        small = x\n    for i in range(1, small + 1):\n        iterations += 1\n        if (x % i == 0) and (y % i == 0):\n            gcd = i\n\n    return gcd, iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(12)\n</code></pre></p> <p> <pre><code>def gcd(x, y):\n    # use Euclidean Algorithm\n    iterations = 0\n    while y:\n        iterations += 1\n        x, y = y, x % y\n    return abs(x), iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(12)\n</code></pre></p> <p> <pre><code>def gcd(x, y):\n    # use Euclidean Algorithm\n    iterations = 0\n    while y:\n        iterations += 1\n        x, y = y, x % y\n    return abs(x), iterations\n\n\ndef test_gcd():\n    result, iterations = gcd(12, 18)\n\n    assert result == snapshot(6)\n    assert iterations &lt;= snapshot(3)\n</code></pre></p> <p>Warning</p> <p>This should not be used to check for any flaky values like the runtime of some code, because it will randomly break your tests.</p> <p>The same snapshot value can also be used in multiple assertions.</p> original code--inline-snapshot=create <p> <pre><code>def test_something():\n    value = snapshot()\n\n    assert 5 &lt;= value\n    assert 6 &lt;= value\n</code></pre></p> <p> <pre><code>def test_something():\n    value = snapshot(6)\n\n    assert 5 &lt;= value\n    assert 6 &lt;= value\n</code></pre></p>"},{"location":"cmp_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> record the new value and store it in the source code if it is contradicts the comparison.</li> <li><code>trim</code> record the new value and store it in the source code if it is more strict than the old one.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>Default configuration:</p> <pre><code>[tool.inline-snapshot]\nhash-length=15\n</code></pre> <ul> <li>hash-length specifies the length of the hash used by <code>external()</code> in the code representation.     This does not affect the hash length used to store the data.     The hash should be long enough to avoid hash collisions.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome. Please create an issue before writing a pull request so we can discuss what needs to be changed.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>The code can be tested with nox</p> <ul> <li><code>nox</code> can be used to test all supported python versions and to check for coverage.</li> <li><code>nox -e test-3.10 -- --sw</code> runs pytest for python 3.10 with the <code>--sw</code> argument.</li> </ul>"},{"location":"contributing/#coverage","title":"Coverage","text":"<p>This project has a hard coverage requirement of 100%. The goal here is to find different edge cases which might have bugs.</p> <p>However, it is possible to exclude some code from the coverage.</p> <p>Code can be marked with <code>pragma: no cover</code>, if it can not be tested for some reason. This makes it easy to spot uncovered code in the source.</p> <p>Impossible conditions can be handled with <code>assert False</code>. <pre><code>if some_condition:\n    ...\nif some_other_codition:\n    ...\nelse:\n    assert False, \"unreachable because ...\"\n</code></pre> This serves also as an additional check during runtime.</p>"},{"location":"contributing/#commits","title":"Commits","text":"<p>Please use pre-commit for your commits.</p>"},{"location":"eq_snapshot/","title":"x == snapshot()","text":""},{"location":"eq_snapshot/#general","title":"General","text":"<p>A snapshot can be compared with any value using <code>==</code>. The value can be recorded with <code>--inline-snapshot=create</code> if the snapshot is empty. The value can later be changed with <code>--inline-snapshot=fix</code> if the value the snapshot is compared with has changed.</p> <p>Example:</p> original code--inline-snapshot=createvalue changed--inline-snapshot=fix <p> <pre><code>def test_something():\n    assert 2 + 4 == snapshot()\n</code></pre></p> <p> <pre><code>def test_something():\n    assert 2 + 4 == snapshot(6)\n</code></pre></p> <p> <pre><code>def test_something():\n    assert 2 + 40 == snapshot(4)\n</code></pre></p> <p> <pre><code>def test_something():\n    assert 2 + 40 == snapshot(42)\n</code></pre></p>"},{"location":"eq_snapshot/#dirty-equals","title":"dirty-equals","text":"<p>It might be, that larger snapshots with many lists and dictionaries contain some values which change frequently and are not relevant for the test. They might be part of larger data structures and be difficult to normalize.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\"date\": datetime.datetime(2024, 3, 14, 0, 0), \"payload\": \"some data\"}\n    )\n</code></pre></p> <p>inline-snapshot tries to change only the values that it needs to change in order to pass the equality comparison. This allows to replace parts of the snapshot with dirty-equals expressions. This expressions are preserved as long as the <code>==</code> comparison with them is <code>True</code>.</p> <p>Example:</p> using IsDatetime()changed payload--inline-snapshot=fix <p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"some data\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"some data\",\n        }\n    )\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"data changed for some good reason\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"some data\",\n        }\n    )\n</code></pre></p> <p> <pre><code>from inline_snapshot import snapshot\nfrom dirty_equals import IsDatetime\nimport datetime\n\n\ndef get_data():\n    return {\n        \"date\": datetime.datetime.utcnow(),\n        \"payload\": \"data changed for some good reason\",\n    }\n\n\ndef test_function():\n    assert get_data() == snapshot(\n        {\n            \"date\": IsDatetime(),\n            \"payload\": \"data changed for some good reason\",\n        }\n    )\n</code></pre></p> <p>Note</p> <p>The current implementation looks only into lists, dictionaries and tuples and not into the representation of other data structures.</p>"},{"location":"eq_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> record the value parts and store them in the source code if it is different from the current one.</li> <li><code>update</code> update parts of the value if their representation has changed.   Parts which are replaced with dirty-equals expressions are not updated.</li> </ul>"},{"location":"getitem_snapshot/","title":"snapshot()[key]","text":""},{"location":"getitem_snapshot/#general","title":"General","text":"<p>It is possible to generate sub-snapshots during runtime. This sub-snapshots can be used like a normal snapshot.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>def test_something():\n    s = snapshot()\n\n    assert s[\"a\"] == 4\n    assert s[\"b\"] == 5\n</code></pre></p> <p> <pre><code>def test_something():\n    s = snapshot({\"a\": 4, \"b\": 5})\n\n    assert s[\"a\"] == 4\n    assert s[\"b\"] == 5\n</code></pre></p> <p><code>s[key]</code> can be used with every normal snapshot operation including <code>s[key1][key2]</code>.</p>"},{"location":"getitem_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined or create a new sub-snapshot if one is missing.</li> <li><code>trim</code> remove sub-snapshots if they are not needed any more.</li> </ul> <p>The flags <code>fix</code> and <code>update</code> are applied recursive to all sub-snapshots.</p>"},{"location":"in_snapshot/","title":"x in snapshot()","text":""},{"location":"in_snapshot/#general","title":"General","text":"<p>It is possible to check if an value is in a snapshot. The value of the generated snapshot will be a list of all values which are tested.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>def test_something():\n    s = snapshot()\n\n    assert 5 in s\n    assert 5 in s\n    assert 8 in s\n\n    for v in [\"a\", \"b\"]:\n        assert v in s\n</code></pre></p> <p> <pre><code>def test_something():\n    s = snapshot([5, 8, \"a\", \"b\"])\n\n    assert 5 in s\n    assert 5 in s\n    assert 8 in s\n\n    for v in [\"a\", \"b\"]:\n        assert v in s\n</code></pre></p>"},{"location":"in_snapshot/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>create</code> create a new value if the snapshot value is undefined.</li> <li><code>fix</code> adds a value to the list if it is missing.</li> <li><code>trim</code> removes a value from the list if it is not necessary.</li> </ul>"},{"location":"outsource/","title":"outsource(data)","text":""},{"location":"outsource/#general","title":"General","text":"<p>Storing snapshots in the source code is the main feature of inline snapshots. This has the advantage that you can easily see changes in code reviews. But it also has some problems:</p> <ul> <li>It is problematic to snapshot a lot of data, because it takes up a lot of space in your tests.</li> <li>Binary data or images are not readable in your tests.</li> </ul> <p>The <code>outsource()</code> function solves this problem and integrates itself nicely with the inline snapshot. It stores the data in a special <code>external()</code> object that can be compared in snapshots. The object is represented by the hash of the data. The actual data is stored in a separate file in your project.</p> <p>This allows the test to be renamed and moved around in your code without losing the connection to the stored data.</p> <p>Example:</p> original code--inline-snapshot=create <p> <pre><code>def test_something():\n    assert outsource(\"long text\\n\" * 1000) == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import external\n\n\ndef test_something():\n    assert outsource(\"long text\\n\" * 1000) == snapshot(\n        external(\"f5a956460453*.txt\")\n    )\n</code></pre></p> <p>The <code>external</code> object can be used inside other data structures.</p> original code--inline-snapshot=create <p> <pre><code>def test_something():\n    assert [\n        outsource(\"long text\\n\" * times) for times in [50, 100, 1000]\n    ] == snapshot()\n</code></pre></p> <p> <pre><code>from inline_snapshot import external\n\n\ndef test_something():\n    assert [\n        outsource(\"long text\\n\" * times) for times in [50, 100, 1000]\n    ] == snapshot(\n        [\n            external(\"362ad8374ed6*.txt\"),\n            external(\"5755afea3f8d*.txt\"),\n            external(\"f5a956460453*.txt\"),\n        ]\n    )\n</code></pre></p>"},{"location":"outsource/#api","title":"API","text":""},{"location":"outsource/#inline_snapshot.outsource","title":"<code>outsource(data, *, suffix=None)</code>","text":"<p>Outsource some data into an external file.</p> <pre><code>&gt;&gt;&gt; png_data = b\"some_bytes\"  # should be the replaced with your actual data\n&gt;&gt;&gt; outsource(png_data, suffix=\".png\")\nexternal(\"212974ed1835*.png\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, bytes]</code> <p>data which should be outsourced. strings are encoded with <code>\"utf-8\"</code>.</p> required <code>suffix</code> <code>Optional[str]</code> <p>overwrite file suffix. The default is <code>\".bin\"</code> if data is an instance of <code>bytes</code> and <code>\".txt\"</code> for <code>str</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>external</code> <p>The external data.</p>"},{"location":"outsource/#inline_snapshot.external","title":"<code>external(name)</code>","text":"<p>External objects are used as a representation for outsourced data. You should not create them directly.</p> <p>The external data is stored inside <code>.inline_snapshot/external</code>. Data which is outsourced but not referenced in the source code jet has a '-new' suffix in the filename.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the external stored object.</p> required"},{"location":"outsource/#inline_snapshot.external.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Two external objects are equal if they have the same hash and suffix.</p>"},{"location":"outsource/#inline_snapshot.external.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the representation of the external object.</p> <p>The length of the hash can be specified in the config.</p>"},{"location":"outsource/#pytest-options","title":"pytest options","text":"<p>It interacts with the following <code>--inline-snapshot</code> flags:</p> <ul> <li><code>trim</code> removes every snapshots form the storage which is not referenced with <code>external(...)</code> in the code.</li> </ul>"},{"location":"pytest/","title":"pytest integration","text":"<p>inline-snapshot comes with a pytest plugin which offers the following options.</p>"},{"location":"pytest/#-inline-snapshot","title":"--inline-snapshot=...","text":"<ul> <li>--inline-snapshot=create:     creates snapshots which are currently not defined</li> <li>--inline-snapshot=update:     update snapshots if they changed their representation (result of <code>repr()</code>)</li> <li> <p>--inline-snapshot=trim:     changes the snapshot in a way which will make the snapshot more precise (see <code>value in snapshot()</code> and <code>snapshot()[key]</code> ).</p> </li> <li> <p>--inline-snapshot=fix:     change snapshots which are currently breaking your tests (where the result of the snapshot operation is <code>False</code>).</p> </li> </ul> <p>This allows you to control which snapshots you want to modify.</p> original code--inline-snapshot=create--inline-snapshot=trim <p> <pre><code>def test_something():\n    assert 7 &lt;= snapshot(10)  # only changed with trim\n    assert 5 &lt;= snapshot()  # only changed with create\n</code></pre></p> <p> <pre><code>def test_something():\n    assert 7 &lt;= snapshot(10)  # only changed with trim\n    assert 5 &lt;= snapshot(5)  # only changed with create\n</code></pre></p> <p> <pre><code>def test_something():\n    assert 7 &lt;= snapshot(7)  # only changed with trim\n    assert 5 &lt;= snapshot(5)  # only changed with create\n</code></pre></p> <p>It is also possible to provide multiple flags at once:</p> <pre><code>pytest --inline-snapshot=trim,fix\n</code></pre>"},{"location":"pytest/#-inline-snapshot-disable","title":"--inline-snapshot-disable","text":"<p>Disables all the snapshot logic. <code>snapshot(x)</code> will just return <code>x</code>.</p>"}]}